# CS13
## 네트워크의 흐름
> DNS 조회, Socket 생성, 연결하고 요청을 보내서 응답을 받을 때 까지 흐름을 설명한다.

### 1. 브라우저에서 URL을 해독하고 HTTP 요청 메시지를 생성.
- 브라우저가 웹 서버에 보내는 요청 메시지를 작성하기 위해 URL 해독.
- 브라우저는 HTTP 프로토콜을 이용해 웹 서버와 파일명을 판단.
- 브라우저가 HTTP 요청 메시지를 생성.

#### 📌 Request Message(요청 메시지)
![img_1.png](img_1.png)   
❕GET 메서드의 경우 메서드와 URI 만으로 웹 서버가 무엇을 할지 판단할 수 있으므로 메시지 본문에 쓰는 송신 데이터는 아무것도 없음.

### 2. 웹 서버의 IP주소를 DNS 서버에 조회
- HTTP의 요청 메시지를 만들면, 이것을 OS에 의뢰해 웹 서버에게 송신.
  - 브라우저는 URL을 해독하고 HTTP 메시지를 생성하지만, 메시지를 네트워크에 송출하는 역할은 OS에서 처리.
- 이 때 URL 안에 쓰여있는 서버의 도메인 명에서 IP 주소를 조사해야 함.
  - 왜냐하면 OS에 송신을 의뢰할 때는 도메인 명이 아닌 IP 주소로 상대를 지정해야 하기 때문.

#### 📌 DNS
Domain Name System   
도메인 명과 IP 주소를 대응시키기 위해 사용.

#### 📌 OS에서 DNS를 이용하는 과정
- OS에서 도메인에 해당하는 IP주소를 찾기 위해 가장 가까운 DNS 서버에게 DNS 요청.
  - DNS 서버에 조회한다는 것은 DNS 서버에 조회 메시지를 보내고, 반송되는 응답 메시지를 받는 것.
  - 이때 DNS 서버로 조회하는 역할을 수행하는 것은 **DNS 리졸버**. 
  - 이 리졸버는 Socket 라이브러리에 포함되어 있음.
- 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 보내고, DNS 서버에서 응답 메시지가 돌아오면 IP주소를 추출해서 브라우저에서 지정한 메모리 영역에 써넣음. 

### 3. 프로토콜 스택에 메시지 송신을 의뢰
- DNS 리졸버를 통해 DNS 서버로부터 IP주소를 알게되면, IP주소의 상대인 웹 서버에 메시지를 송신하도록 OS 내부에 있는 프로토콜 스택에 의뢰.

데이터를 송수신하는 컴퓨터 사이에는 데이터의 통로 같은 것이 있음. // Stream?   
이것을 통해 데이터가 흐르면서 상대 측에 도착하는데, 이 통로를 파이프라고 할 수 있음.   
그래서 한쪽 끝에서 파이프에 데이터를 쏟아부으면 파이프를 통해 반대쪽 끝까지 도착하고, 거기에서 데이터를 추출할 수 있음.   
먼저 파이프에 데이터를 송수신하기 전에 클라이언트오 서버 사이에 파이프를 연결하는 동작이 핋요함.   
이 부분의 요점은 파이프 양 끝에 있는 데이터의 출입구로, ```소켓```이라고 부름.

- 먼저 서버 측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다림.
- 이렇게 서버 측이 기다리는 동안 클라이언트 측에서 소켈을 만들고, 소켓에서 파이프를 늘력 서버 측의 소켓에 연결.
- 연결되면 준비가 완료된 것으로, 이제 소켓에서 데이터를 쏟아 붓듯이 데이터 송수신 동작을 실행.
- 송수신 동작이 끝나면 연결했던 파이프가 분리됨.

### 정리하면
- 소켓을 생성한다. (소켓 작성)
- 서버 측의 소켓에 파이프를 연결한다. (접속)
- 데이터를 송수신한다. (송수신)
- 파이프를 분리하고 소켓을 말소한다. (연결 끊기)

❕이 네 가지 동작을 실행하는 것은 OS 내부의 프로토콜 스택.   
(브라우저 등의 애플리케이션은 자체에서 파이프를 연결하거나 데이터를 전송하지 않고, 프로토콜 스택에 의뢰해서 파이프를 연결하거나 데이터를 전송함)


#### 📌 데이터 송수신 과정 정리
1. 소켓의 작성 단계
- 클라이언트에서 소켓 라이브러리의 socket을 이용해 **소켓을 생성**.
- 소켓이 생성되면 **소켓을 식별**하는 **디스크립터**가 돌아오고 애플리케이션은 이것을 메모리에 기록해둠.

2. 파이프 연결 단계
- 만든 소켓을 서버 측의 소켓에 접속하도록 프로토콜 스택에 의뢰.
  - 소켓 라이브러의 connect를 호출해 의뢰 동작 실행
  - 이때 지정하는 값은 **디스크립터, 서버의 IP주소, 포트 번호** 
    - 디스크립터 : 클라이언트 내부의 소켓을 식별하기 위해 사용
    - 포트 번호 : 상대 측에서 소켓을 식별하기 위해 사용

3. 송수신 단계
- 소켓이 상대측과 연결되면 소켓에서 데이터를 쏟아 붓고 상대측의 소켓에 데이터가 도착.
- 우선 애플리케이션은 송신 데이터를 메모리에 준비하고, 소켓 라이브러리의 write를 호출할 때 디스크립터와 송신 데이터를 지정함.
- 프로토콜 스택이 송신 데이터를 서버에게 송신함.
  - 소켓에는 연결된 상대가 기록되어 있어 디스크립터로 소켓을 지정하면 연결된 상대가 판명되어 그곳을 향해 데이터를 송신함)
- 서버는 수신 동작을 실행해서 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메시지를 반송함.
- 이 메시지를 read를 통해 받아서 수신 버터에 저장하고, 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네줌.

4. 연결 끊기 단계와 송수신 종료
- 브라우저가 데이터 수신을 완료하면 송수신 동작은 끝남.
- 그 후 라이브러리의 close를 호출하여 연결 끊기를 의뢰하면 소켓 사이를 연결한 파이프와 같은 것이 분리되고 소켓도 말소됨.

❕이러한 흐름으로 HTTP 프로토콜은 1개의 데이터를 읽을 때마다 접속, 요청 메시지 송신, 응답메시지 수신, 연결 끊기라는 동작을 반복.

----

> 각자 작성한 네트워크 프로그래밍 비동기 API 동작 방식에 대해 설명한다.

작성중..

> 각 언어와 플랫폼에서 BSD 소켓 API에 대해 조사해보고 설명한다.

작성중..

> 회로 스위칭 방식보다 패킷 스위칭 방식이 효율적인 이유를 설명한다.

작성중..

## 📑 References
[[10분 테코톡] 🎧 삭정의 Web 요청 & 응답과정](https://youtube.com/watch?v=0jV7xOUcKog&feature=shares)   
[쿠키, 세션, 캐시가 뭔가요?](https://youtube.com/watch?v=OpoVuwxGRDI&feature=shares)   
[네트워크의 흐름 1단계](https://willseungh0.tistory.com/143)   
[네트워크의 흐름 2단계](https://willseungh0.tistory.com/144)

